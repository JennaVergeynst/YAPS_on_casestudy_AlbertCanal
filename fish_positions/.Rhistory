## split according to the combo passing-chunk
chunk_list <- split(data_rebind, data_rebind[,c('groups_pas', 'chunks')])
## remove empty dataframes from list
remove <- sapply(chunk_list, function(i) dim(i)[1]==0)
chunk_list <- chunk_list[!remove]
# Make the grid centred close to 0;0 (not absolutely necessary, but don't work with UTM coordinates)
X_shift <- 0
Y_shift <- 0
toa_list_el = chunk_list$`0.1`
time_col='synced_time'
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, rbi_min, rbi_max,
X_shift, Y_shift, results_path, chunk_len = '2000', time_col='synced_time')
path
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fixed_tags.R')
## Parameters
pingType = 'rbi'
mean_bi = 600
rbi_min = 540
rbi_max = 660
ID = '65043'
self = 'ST15'
chunk_len <- 500
## Data
data <- read.csv(paste('TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
toa_df <- data %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_df)
hydros <- hydro_data[rownames(hydro_data) %in% receivers, c('X','Y')]
colnames(hydros) <- c('hx', 'hy')
colnames(toa_df) == rownames(hydros)
toa_all <- as.matrix(toa_df)
ss_all <- data$soundspeed
## Sync tag is co-located with self receiver
focal_hydro   <- which(rownames(hydros) == self)
focal_toa_col <- which(colnames(toa_all) == self)
## estimating distances from the self based on hydro positions and data in TOA
hydros_dt <- data.table(hydros)
hydros_dt[, name:=rownames(hydros)]
hydros_dt[, dist2focal:=sqrt((hx-hx[focal_hydro])^2 + (hy-hy[focal_hydro])^2)]
hydros_dt[, dist_from_toa:=colMeans((toa_all- toa_all[,focal_toa_col])*1460, na.rm=TRUE)]
hydros_dt[, dist_diffs:= abs(dist2focal - dist_from_toa)]
hydros_dt
## Remove behind-the-corner receivers (in this case ST7, ST10, ST12)
corner_idx <- which(hydros_dt$dist_diffs>20)
corner_hydros <- hydros_dt$name[corner_idx]
data[, which(colnames(data) %in% c(corner_hydros,self))] <- NA
## Split data according to passings, and then each passing in chunks of 1000
data$chunks <- 0
## split along passings
passings_list <- split(data, data$groups_pas)
## add chunks to passings that are too long
for (i in 1:length(passings_list)){
if (dim(passings_list[[i]])[1]>chunk_len){
passings_list[[i]] <- chunk_toa(passings_list[[i]], chunk_len)
}
}
## remake the dataframe
data_rebind <- bind_rows(passings_list)
## split according to the combo passing-chunk
chunk_list <- split(data_rebind, data_rebind[,c('groups_pas', 'chunks')])
## remove empty dataframes from list
remove <- sapply(chunk_list, function(i) dim(i)[1]==0)
chunk_list <- chunk_list[!remove]
# Make the grid centred close to 0;0 (not absolutely necessary, but don't work with UTM coordinates)
X_shift <- 0
Y_shift <- 0
toa_list_el = chunk_list$`0.1`
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, rbi_min, rbi_max,
X_shift, Y_shift, results_path, chunk_len = '2000', time_col='synced_time')
track <- track_res_list[[1]]
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fixed_tags.R')
## Parameters
pingType = 'rbi'
mean_bi = 600
rbi_min = 540
rbi_max = 660
ID = '65043'
self = 'ST15'
chunk_len <- 2000
## Data
data <- read.csv(paste('TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
toa_df <- data %>% dplyr:: select(starts_with("ST"))
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fixed_tags.R')
## Parameters
pingType = 'rbi'
mean_bi = 600
rbi_min = 540
rbi_max = 660
ID = '65043'
self = 'ST15'
chunk_len <- 2000
## Data
data <- read.csv(paste('TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
toa_df <- data %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_df)
hydros <- hydro_data[rownames(hydro_data) %in% receivers, c('X','Y')]
colnames(hydros) <- c('hx', 'hy')
colnames(toa_df) == rownames(hydros)
toa_all <- as.matrix(toa_df)
ss_all <- data$soundspeed
## Sync tag is co-located with self receiver
focal_hydro   <- which(rownames(hydros) == self)
focal_toa_col <- which(colnames(toa_all) == self)
## estimating distances from the self based on hydro positions and data in TOA
hydros_dt <- data.table(hydros)
hydros_dt[, name:=rownames(hydros)]
hydros_dt[, dist2focal:=sqrt((hx-hx[focal_hydro])^2 + (hy-hy[focal_hydro])^2)]
hydros_dt[, dist_from_toa:=colMeans((toa_all- toa_all[,focal_toa_col])*1460, na.rm=TRUE)]
hydros_dt[, dist_diffs:= abs(dist2focal - dist_from_toa)]
hydros_dt
## Remove behind-the-corner receivers (in this case ST7, ST10, ST12) and self-receiver
corner_idx <- which(hydros_dt$dist_diffs>20)
corner_hydros <- hydros_dt$name[corner_idx]
data[, which(colnames(data) %in% c(corner_hydros,self))] <- NA
View(data)
## Split data according to passings, and then each passing in chunks of 1000
data$chunks <- 0
## split along passings
passings_list <- split(data, data$groups_pas)
## add chunks to passings that are too long
for (i in 1:length(passings_list)){
if (dim(passings_list[[i]])[1]>chunk_len){
passings_list[[i]] <- chunk_toa(passings_list[[i]], chunk_len)
}
}
## remake the dataframe
data_rebind <- bind_rows(passings_list)
## split according to the combo passing-chunk
chunk_list <- split(data_rebind, data_rebind[,c('groups_pas', 'chunks')])
## remove empty dataframes from list
remove <- sapply(chunk_list, function(i) dim(i)[1]==0)
chunk_list <- chunk_list[!remove]
# Make the grid centred close to 0;0 (not absolutely necessary, but don't work with UTM coordinates)
X_shift <- 0
Y_shift <- 0
toa_list_el = chunk_list$`0.1`
View(chunk_list)
# Run yaps and write out the result and residuals (or the timeperiod if the run failed)
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, rbi_min, rbi_max,
X_shift, Y_shift, results_path, chunk_len = toString(chunk_len), time_col='synced_time')
# Check track
track <- track_res_list[[1]]
residuals <- track_res_list[[2]]
colMeans(residuals, na.rm = TRUE) # average residual per receiver
rowMeans(residuals, na.rm = TRUE) # average residual per calculated position
View(passings_list)
View(data)
View(data)
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fixed_tags.R')
## Parameters
pingType = 'rbi'
mean_bi = 600
rbi_min = 540
rbi_max = 660
ID = '65043'
self = 'ST15'
chunk_len <- 2000
## Data
data <- read.csv(paste('TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
subdata <- data[1:8000,]
View(subdata)
write.csv(subdata, 'TOA_data_65043.csv')
## Data
data <- read.csv(paste('TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
subdata <- data[1:6000,]
write.csv(subdata, 'TOA_data_65043.csv')
## Data
data <- read.csv(paste('TOA_data_sample_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
toa_df <- data %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_df)
hydros <- hydro_data[rownames(hydro_data) %in% receivers, c('X','Y')]
colnames(hydros) <- c('hx', 'hy')
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fixed_tags.R')
## Parameters
pingType = 'rbi'
mean_bi = 600
rbi_min = 540
rbi_max = 660
ID = '65043'
self = 'ST15'
chunk_len <- 2000
## Data
data <- read.csv(paste('TOA_data_sample_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
toa_df <- data %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_df)
View(data)
View(data)
## Data
data <- read.csv(paste('../TOA_data_sample_',toString(ID),'.csv',sep = ''),check.names = FALSE)
## Data
data <- read.csv(paste('../TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
View(data)
subdata <- data[1:6000,]
write.csv(subdata, 'TOA_data_sample_65043.csv',row.names=FALSE)
## Data
data <- read.csv(paste('../TOA_data_sample_',toString(ID),'.csv',sep = ''),check.names = FALSE)
View(data)
## Data
data <- read.csv(paste('TOA_data_sample_',toString(ID),'.csv',sep = ''),check.names = FALSE)
View(data)
data$ID <- ID
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
toa_df <- data %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_df)
hydros <- hydro_data[rownames(hydro_data) %in% receivers, c('X','Y')]
colnames(hydros) <- c('hx', 'hy')
colnames(toa_df) == rownames(hydros)
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fixed_tags.R')
## Parameters
pingType = 'rbi'
mean_bi = 600
rbi_min = 540
rbi_max = 660
ID = '65043'
self = 'ST15'
chunk_len <- 2000
## Data
data <- read.csv(paste('TOA_data_sample_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
toa_df <- data %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_df)
hydros <- hydro_data[rownames(hydro_data) %in% receivers, c('X','Y')]
colnames(hydros) <- c('hx', 'hy')
colnames(toa_df) == rownames(hydros)
toa_all <- as.matrix(toa_df)
ss_all <- data$soundspeed
## Sync tag is co-located with self receiver
focal_hydro   <- which(rownames(hydros) == self)
focal_toa_col <- which(colnames(toa_all) == self)
## estimating distances from the self based on hydro positions and data in TOA
hydros_dt <- data.table(hydros)
hydros_dt[, name:=rownames(hydros)]
hydros_dt[, dist2focal:=sqrt((hx-hx[focal_hydro])^2 + (hy-hy[focal_hydro])^2)]
hydros_dt[, dist_from_toa:=colMeans((toa_all- toa_all[,focal_toa_col])*1460, na.rm=TRUE)]
hydros_dt[, dist_diffs:= abs(dist2focal - dist_from_toa)]
hydros_dt
## Remove behind-the-corner receivers (in this case ST7, ST10, ST12) and self-receiver
corner_idx <- which(hydros_dt$dist_diffs>20)
corner_hydros <- hydros_dt$name[corner_idx]
data[, which(colnames(data) %in% c(corner_hydros,self))] <- NA
## Split data according to passings, and then each passing in chunks
data$chunks <- 0
## split along passings
passings_list <- split(data, data$groups_pas)
## add chunks to passings that are too long
for (i in 1:length(passings_list)){
if (dim(passings_list[[i]])[1]>chunk_len){
passings_list[[i]] <- chunk_toa(passings_list[[i]], chunk_len)
}
}
## remake the dataframe
data_rebind <- bind_rows(passings_list)
## split according to the combo passing-chunk
chunk_list <- split(data_rebind, data_rebind[,c('groups_pas', 'chunks')])
## remove empty dataframes from list
remove <- sapply(chunk_list, function(i) dim(i)[1]==0)
chunk_list <- chunk_list[!remove]
# Make the grid centred close to 0;0 (not absolutely necessary, but don't work with UTM coordinates)
X_shift <- 0
Y_shift <- 0
toa_list_el = chunk_list$`0.1`
# Run yaps and write out the result and residuals (or the timeperiod if the run failed)
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, rbi_min, rbi_max,
X_shift, Y_shift, results_path, chunk_len, time_col='synced_time')
View(toa_list_el)
View(chunk_list)
View(chunk_list)
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fish_tags.R')
## Parameters
pingType = 'rbi' # min and max bi is checked inside function
hydro_data<- read.csv(paste0(path, '/Receiver_location.csv'),row.names = 'station_name')
results_path <- paste0(path,'/Deployment1')
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
results_path <- paste0(path,'/Deployment1')
# Make the grid centred close to 0;0 (not absolutely necessary, but don't work with UTM coordinates)
X_shift <- 0
Y_shift <- 0
## Data
ID = '100'
data <- read.csv(paste(path,'/TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
## split along passings
passings_list <- split(data, data$groups_pas)
## Run one track
toa_list_el = passings_list$'1'
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, X_shift, Y_shift, results_path, time_col='synced_time')
track <- track_res_list[[1]]
residuals <- track_res_list[[2]]
colMeans(residuals, na.rm = TRUE) # average residual per receiver
rowMeans(residuals, na.rm = TRUE) # average residual per calculated position
X <- track$X
Y <- track$Y
plot(X,Y)
est_error <- sqrt(track$Xe**2+track$Ye**2)
mean(est_error)
View(passings_list)
View(passings_list)
View(passings_list)
## Run one track
toa_list_el = passings_list$'0'
## Run one track
toa_list_el = passings_list$'0'
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, X_shift, Y_shift, results_path, time_col='synced_time')
## Run one track
toa_list_el = passings_list$'2'
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, X_shift, Y_shift, results_path, time_col='synced_time')
## Run one track
toa_list_el = passings_list$'2'
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, X_shift, Y_shift, results_path, time_col='synced_time')
toa_on_recs <- toa_list_el %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_on_recs)
hydros <- hydro_data[rownames(hydro_data) %in% receivers, c('X','Y')]
colnames(hydros) <- c('hx', 'hy')
colnames(toa_on_recs) == rownames(hydros)
track <- data.frame() # return empty if try runs into error
try({
toa_df <- toa_list_el[,colnames(toa_list_el)%in% receivers]
toa_info <- toa_list_el[,colnames(toa_list_el)%in% receivers==FALSE]
toa <- t(as.matrix(toa_df))
bi_range <- range(diff(colMeans(toa, na.rm=TRUE)), na.rm=TRUE)
rbi_min <- bi_range[1]-2
rbi_max <- bi_range[2]+2
track_and_residuals <- runYAPS(toa, toa_info, hydros, pingType, rbi_min, rbi_max, X_shift, Y_shift, time_col, min_obs)
track <- track_and_residuals[[1]]
residuals_df <- track_and_residuals[[2]]
colnames(residuals_df) <- receivers
})
time_col='synced_time', min_obs=3
time_col='synced_time'
min_obs=3
try({
toa_df <- toa_list_el[,colnames(toa_list_el)%in% receivers]
toa_info <- toa_list_el[,colnames(toa_list_el)%in% receivers==FALSE]
toa <- t(as.matrix(toa_df))
bi_range <- range(diff(colMeans(toa, na.rm=TRUE)), na.rm=TRUE)
rbi_min <- bi_range[1]-2
rbi_max <- bi_range[2]+2
track_and_residuals <- runYAPS(toa, toa_info, hydros, pingType, rbi_min, rbi_max, X_shift, Y_shift, time_col, min_obs)
track <- track_and_residuals[[1]]
residuals_df <- track_and_residuals[[2]]
colnames(residuals_df) <- receivers
})
toa_df <- toa_list_el[,colnames(toa_list_el)%in% receivers]
toa_info <- toa_list_el[,colnames(toa_list_el)%in% receivers==FALSE]
toa <- t(as.matrix(toa_df))
bi_range <- range(diff(colMeans(toa, na.rm=TRUE)), na.rm=TRUE)
rbi_min <- bi_range[1]-2
rbi_max <- bi_range[2]+2
track_and_residuals <- runYAPS(toa, toa_info, hydros, pingType, rbi_min, rbi_max, X_shift, Y_shift, time_col, min_obs)
# Make the grid centred close to 0;0 (not absolutely necessary, but don't work with UTM coordinates)
hydros[,'hx'] <- hydros[,'hx'] - X_shift
hydros[,'hy'] <- hydros[,'hy'] - Y_shift
DATETIME <- toa_info[,time_col]
ss_measured <- toa_info$soundspeed
#chunk_nb <- toa_info$chunks[[1]]
groups_pas <- toa_info$groups_pas[[1]]
track <- data.frame() # return empty if try runs into error
residuals_df <- data.frame() # return empty if try runs into error
# YAPS is most sensible to few observation in head and tail
# throw away observations in head and tail where nobs < 3 and nobs10 < 2
# If nobs is overall too small, code below will return error
nobs <- apply(toa, 2, function(k) sum(!is.na(k))) # notNA sum over columns
nobs10 <- caTools::runmean(nobs, 10) # running mean over 10 elements
first <- which(nobs10 >= 2 & nobs >= min_obs)[1]
last <- rev(which(nobs10 >= 2 & nobs >= min_obs))[1]
## Run one track
toa_list_el = passings_list$'0'
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, X_shift, Y_shift, results_path, time_col='synced_time')
toa_on_recs <- toa_list_el %>% dplyr:: select(starts_with("ST"))
receivers <- colnames(toa_on_recs)
hydros <- hydro_data[rownames(hydro_data) %in% receivers, c('X','Y')]
colnames(hydros) <- c('hx', 'hy')
colnames(toa_on_recs) == rownames(hydros)
track <- data.frame() # return empty if try runs into error
try({
toa_df <- toa_list_el[,colnames(toa_list_el)%in% receivers]
toa_info <- toa_list_el[,colnames(toa_list_el)%in% receivers==FALSE]
toa <- t(as.matrix(toa_df))
bi_range <- range(diff(colMeans(toa, na.rm=TRUE)), na.rm=TRUE)
rbi_min <- bi_range[1]-2
rbi_max <- bi_range[2]+2
track_and_residuals <- runYAPS(toa, toa_info, hydros, pingType, rbi_min, rbi_max, X_shift, Y_shift, time_col, min_obs)
track <- track_and_residuals[[1]]
residuals_df <- track_and_residuals[[2]]
colnames(residuals_df) <- receivers
})
groups_pas <- toa_list_el$groups_pas[[1]]
ID <- toa_list_el$ID[[1]]
write.csv(track,paste0(results_path,'/track_',toString(ID),'_pass_', toString(groups_pas), '.csv'))
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, X_shift, Y_shift, results_path, time_col='synced_time')
results_path
rm(list=ls())
graphics.off()
## For R-studio:
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set file directory as working directory
path <- getwd()
results_path <- path
library(yaps)
library("parallel")
library(dplyr)
library(data.table)
source('yaps_functions_for_fish_tags.R')
## Parameters
pingType = 'rbi' # min and max bi is checked inside function
hydro_data<- read.csv(paste0(path, '/../Receiver_location.csv'),row.names = 'station_name')
# Make the grid centred close to 0;0 (not absolutely necessary, but don't work with UTM coordinates)
X_shift <- 0
Y_shift <- 0
## Data
ID = '100'
data <- read.csv(paste(path,'/TOA_data_',toString(ID),'.csv',sep = ''),check.names = FALSE)
data$ID <- ID
## split along passings
passings_list <- split(data, data$groups_pas)
## Run one track
toa_list_el = passings_list$'0'
track_res_list <- prepare_and_run(toa_list_el, hydro_data, pingType, X_shift, Y_shift, results_path, time_col='synced_time')
track <- track_res_list[[1]]
residuals <- track_res_list[[2]]
colMeans(residuals, na.rm = TRUE) # average residual per receiver
rowMeans(residuals, na.rm = TRUE) # average residual per calculated position
X <- track$X
Y <- track$Y
plot(X,Y)
est_error <- sqrt(track$Xe**2+track$Ye**2)
mean(est_error)
## Run all tracks in parallel
ptm <- proc.time()
cl = makeCluster(4, outfile="") # Adapt to number of cores on your system
clusterExport(cl, list("prepare_and_run", "runYAPS", "runTrack", "getInp", "runTmb"))
track <- clusterApplyLB(cl, passings_list, prepare_and_run, hydro_data, pingType,
X_shift, Y_shift, results_path, time_col='synced_time')
